---
title: Building a Forum with Clojure, Datomic, Angular, and Ansible
created_at: Sat Jul 20 2013 19:23:00 -0500
kind: article
categories: programming
summary: ""
---

After many long months I've finished re-writing
[Grateful Place](http://gratefulplace.com). The site now uses Clojure
as an API server, with Datomic for the database, Angular for the front
end, and Vagrant and Ansible for provisioning and deployment. Below
I'll dive into the code base, describing the most important parts of
each component and how everything works together. We'll cover:

* Clojure API Server
    * Liberator for Easy API'ing
    * Authentication with Friend
    * Testing a Clojure Web App is More Fun than Testing Rails
    * Serving files generated by Grunt/Angular
    * The Web App as an Executable
* Datomic
    * Why Oh Why Did I Do This
    * The Poopy Code I Wrote to Make Basic Things "Easier"
    * The Good Code I Ripped Off to do Migrations
    * Mapification with Cartographer, My Very Own Clojure Library!!!
* Angular
    * Peeking and Secondary Controllers
    * Directives to the Rescue
* Infrastructure
    * Creating a Local Sandbox with Vagrant
    * Provisioning with Ansible
    * Building and Deploying with a Janky Bash Script and Ansible
* Workflow
    * Emacs Bookmarks, Snippets, and Keybindings
    * tmux Config

All source is available [on github](https://github.com/flyingmachine/gratefulplace2/tree/v1.0.0).


## About the Site

[Grateful Place](http://gratefulplace.com) is my attempt at creating
the kind of online community that I'd like to belong to. It's still in
its infancy, but I'd like for it to become a site where people
consciously help lift each other up. One way to do this is by
expressing gratitude on a daily basis, which has been shown to
actually increase happiness.

Some of the features include watching treads, liking posts, and
creating a basic profile. I have a lot more planned for the future,
like tags and "summary" views, and I think the combination of Clojure +
Angular will make it fun and easy for me to continue development :)

If you want to have a look without diving head-first into hippified
waters (what, do you have something against happiness?), you can
[use the demo site](http://demo.gratefulplace.com).

Now, on to the code!

## Clojure API Server

I'm very happy with using Clojure as an API server. The libraries
involved are lightweight and transparent, with no magic, and that
makes it so easy to fully understand what's going on. That was my
experience with Liberator:

### Liberator for Easy API'ing

Liberator provided me with a much better abstraction for handling
logic which I was repeating in all of my controllers. For example, my
`create` functions all basically looked like this before I moved to
Liberator:

```clojure
(defn create!
  [params auth]
  (protect
   (:id auth)
   (if-valid
    params (:create validations/post) errors
    (let [post-map (create-post params)]
      {:body post-map})
    (invalid errors))))
```

The above code implements a decision tree:

1. First, the `protect` macro is used to ensure you're authorized to
do whatever you're trying to do. The first argument is a boolean
expression, in this case `(:id auth)`, which just checks whether
you're logged in. If the boolean expression is true, run everything
that follows. Otherwise return an error status and error messages
([see implementation](https://github.com/flyingmachine/gratefulplace2/blob/v1.0.0/server/src/gratefulplace/models/permissions.clj#L45)).
2. Check whether `params` is valid using the specified validation, in
this case `(:create validations/post)`. If it's valid, run the `let`
statement, otherwise make the validation errors available in `errors`
and run `(invalid errors)`.

There are a couple things that I didn't like about this approach. First,
there was too much distance between the logical branches. For example,
`protect` is basically an if statement, but the `else` is hidden.
Also, the
[actual code](https://github.com/flyingmachine/gratefulplace2/blob/fefbebf463b00328e0bd5660ca5ea33899d7cd39/server/src/gratefulplace/controllers/posts.clj#L33)
I wrote in `if-valid` is a bit long, which makes it difficult to
visually understand how `(invalid errors)` relates.

Second, this approach required me to introduce more nesting in order
to add more steps or checks in the workflow. This would make it even
harder to understand as I'd mentally have to descend and ascend a
few conditionals in order to understand what's going on. I'd end up
with something like:

```
- Decision one
  - Decision one first branch: Decision two
    - Decision two first branch: Decision three
      - Decision three first branch
        ...
        Lots of code here physically creating distance between
        branches
      - Decision three second branch
        ...
        More code causing more distance
    - Decision two second branch
  - Decision one second branch... what was the decision even?
    I can't remember and now it's hard for me to visually
    associate this branch with its parent decision
```

So essentially, I'd have to keep an ever-growing decision tree in my
head. The physical representation of the tree, the code, would help to
obscure the logic flow as I added more code.

Here's how the same function looks when rewritten using Liberator:

```clojure
(defresource create! [params auth]
  :allowed-methods [:post]
  :available-media-types ["application/json"]
  :authorized? (logged-in? auth)

  :malformed? (validator params (:create validations/post))
  :handle-malformed errors-in-ctx

  :post! (create-content ts/create-post params auth record)
  :handle-created record-in-ctx)
```

Holy shnikes! That's so much clearer!

Liberator improved my code by providing a
[pre-defined, HTTP-compliant decision tree](http://clojure-liberator.github.io/liberator/doc/decisions.html),
providing sensible default logic for nodes, and by allowing me to
easily associate my own logic with the nodes. 

This allows me to concentrate on one node at a time, instead of having
to keep an increasingly complicated tree structure in my head. For
example, I can physically place the logic for `malformed?` next to the
code that I want to run if the request *is* malformed, specified by
`handle-malformed`.

Liberator has excellent documentation and using it was a big win. It
gave me the sense of being able to just plug my own bits of logic into
a carefully-coded, useful framework. I definitely recommend it.

### Authentication with Friend

Friend still kinda makes my head hurt.

## Workflow
http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded
