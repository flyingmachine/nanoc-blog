---
title: Refactoring to Datamappers Clojure
created_at: Fri Jul 06 7:47:00 -0500 2012
kind: article
summary: In this post I give a detailed description of a recent refactoring for my site <a href="http://omgsmackdown.com">OMG! SMACKDOWN!!!</a> . I make no attempt to enliven the article with "cats" or "memes" or "humor" - it's straight up code and commentary.
additional_stylesheets:
  - pygments
---


h1. Refactoring to Datamappers in Clojure

In this post I give a detailed description of a recent refactoring for my site "OMG! SMACKDOWN!!!":http://omgsmackdown.com. I make no attempt to enliven the article with "cats" or "memes" or "humor" - it's straight up code and commentary.

The refactoring was largely influenced by Rich Hickey's talk "Simplicity Matters":http://www.confreaks.com/videos/860-railsconf2012-keynote-simplicity-matters. The main purposes were:

# Reduce complexity in the Hickeysian sense - untangle bits of code that don't need to be tangled together
# Introduce an explicit "design":http://www.flyingmachinestudios.com/design/anatomy-of-frustration/
# Reduce repetition

In order to do this, I kept the following guidelines in mind:

# Create clear separation between data and the functions which transform them
# Reduce coupling through information and implementation hiding
# Abstract out the "bones" of functionality

In the process I may have created an even more terrible monster than the one I started with and perhaps lost a few "sanity points":http://www.amazon.com/gp/product/1589942108/ref=as_li_ss_tl?ie=UTF8&tag=aflyingmachin-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=1589942108 but the process was fun and educational.

h2. Quick Project Overview

"OMG! SMACKDOWN!!!":http://omgsmackdown.com/, perhaps one of the most important web sites in Internet history, is a "Noir":http://webnoir.org/ project which allows users (well, just me for now) to create @arenas@ wherein @fighters@ @battle@ it out.

The project code accomplishes the following:

# Show two randomly selected fighters from different teams on the home page
# Record each click on a fighter as a "win" for that fighter
# Allow me to create, update, and delete arenas
# Allow me to create, update, and delete fighters, including their images which get uploaded to S3

It uses "clj-aws-s3":https://github.com/weavejester/clj-aws-s3 and "Clojure Monger":http://clojuremongodb.info/.

All the code discussed here is "available on github":https://github.com/flyingmachine/nanoc-blog/tree/master/content/assets/source/clojure/refactoring-to-datamappers.

h2. The Original Monster

Below is the most complex of my models:

source. clojure/refactoring-to-datamappers/original/fighter.clj

So, yeah, that's a ton of code. Breaking it into two groups, image-handling and CRUD operations, might help to quickly grok it.

The main problem with the fighter model is that it has little explicit structure. There's no design. It's all just "keep doing stuff until you get the result you want." Sure, you have common functionality refactored into separate functions. For instance, @resize-and-save-image@ is needed by both @create@ and @update@, so it gets its own function.

But that's not design. That's coding by convenience. "Well-designed":http://www.flyingmachinestudios.com/design/anatomy-of-frustration/ code is predictable code. It follows a pattern, giving you a headstart when writing new code and allowing you to quickly assimilate unfamiliar parts of the system.

To complete the picture, here's the arena model:

source. clojure/refactoring-to-datamappers/original/arena.clj

As you can see, the functions are essentially the same as those in the fighter model. Good ol' copy-and-paste coding. Clipboard-driven design. One of the cardinal sins of programming. Truly, I am ashamed.

h2. Enter the Hero: Datamapper

(Wow, check out that heading! This is getting epic! As befits an article about a site as majestic and grand as OMG! SMACKDOWN!!!)

I have something embarrasing to admit. I've already revealed my clipboard abuse, and nothing could be as bad that, so here goes: I don't really know what a Model is. Sure, it's the "M" in MVC, it's a staple of software design, it's something that's been in every Rails (and merb! yeah I was one of those guys for awhile) project, large and small, that I've been involved with since I first watched "DHH's Danish-accented, whoops-laden screencast":http://www.youtube.com/watch?v=Gzj723LkRJY.

But in writing the above code, I felt like I was throwing everything into the @fighter@ model out of habit. I kept asking myself, "what _is_ a model, really?" I know, I know, I should stop with the soul searching and get back to the code. What I'm getting at, though, is that Clojure (and to some extent Noir) is really forcing me to re-examine my current habits and assumptions about coding and software design.

Here are the decisions I introduced to impose order:

h3. I'm dealing with "data mappers", not "models"

The code above concerns itself with:

# Transforming user input in order to persist it
# Persisting the transformed data
# Retrieving data from storage
# Transforming retrieved data for consumption by the system

This data-centric view of the world speaks more of lightweight, "dumb" data structures than heavyweight, overly-smart "models". Perhaps the distinction is all in my head, but by using the term "data mapper" I want to communicate that the code's purpose is to act as a pipe - a "map", if you will - between the domain layer and the persistence layer.

h3. Data mappers should clearly distinguish data, transformation, and persistence

In the original @fighter.clj@, I mix together transformation and persistence functions, as you can see below:

source. clojure/refactoring-to-datamappers/original/fighter.clj 67-79

I mean, the name is "resize-AND-save-image". Transform AND persist, mooshed together. This looks like exactly the kind of "complecting" that Rich Hickey talked about. I'm shoving two things together which really don't belong together.

What I decided to instead was to be explicit about the persistence process. Functions should transform input data into a representation appropriate for the storage medium. Then a separate function should store that representation. This way, the persistence function has no knowledge of the transformation function and vice versa.

The same applies to data retrieval. First, retrieve a representation from storage. Next, transform that data using a function. Return the new representation.

One specific benefit I wanted to get out of this process was to remove any need for domain code to translate between string ID's and mongodb's BSON @ObjectIDs@. I had @(idstr fighter)@ littered all throughout my views, and that was ugly and unnecessary.

h2. The Refactored Code

Here's the refactored fighter.clj file:

source. clojure/refactoring-to-datamappers/refactored/fighter.clj

@resize-and-save-image@ has been broken into @input->images@ and @store-image@, lines 67 and 87, and neither has knowledge of the other. I also introduced @create-input->db-fields@ and @update-input->db-fields@.

You might also have noticed some weird code at lines 15-18. The functions being used are here:

source. clojure/refactoring-to-datamappers/refactored/db.clj

Now this is some seriously weird code. I don't know if this is a good idea at all - it doesn't feel like good Clojure or good lisp.

That being said, there are two macros, both of which create new functions in the namespace in which they're called. The first set simply wraps monger functions and keeps me from having to repeat the mongodb collection name argument over and over. The second set of functions performs the storage-to-domain-representation transformations.

You can see in the comments that I feel seriously weirded out by this code. It had me questioning what I'm really using namespaces for. If @idstr@ does the exact same thing in every namespace that it's copied to, then why am I throwing it into multiple namespaces? @add-db-fns@ helps me reduce duplication, but is it really worth it? Perhaps that'll be the subject of another blog post about another refactoring.

For completeness's sake, here's the refactored arena.clj:

source. clojure/refactoring-to-datamappers/refactored/arena.clj

h2. A Scarier Monster?

Some more doubts about the new code:

* Should the image processing code be somewhere else?
* Should I write a wrapper around the S3 code, as I did for the monger code? Should I be more explicit about the representation/persistence relationship?
* How about the @amazon-image-path@ function? Where does that go? In this case, I actually am doing something beyond just mapping data.

h2. The End

Thus ends our exhausting - I mean, exhaustive - tour of this little refactoring. I'd love any feedback on the code!

Special thanks to "Daniel Choi":http://danielchoi.com/software/ for linking to the Rich Hickey talk and to "bostonrb":http://bostonrb.org/ for a great discussion on simplicity.
