---
title: An Exhaustive Explanation of Minimax, a Staple AI Algorithm
created_at: Jan 7 15:44:00 -0500 2012
categories: programming
kind: article
additional_stylesheets:
  - pygments
---

h1. An Exhaustive Explanation of Minimax, a Staple AI Algorithm

h2. Overview

The minimax algorithm is used to determine which moves a computer player makes in games like tic-tac-toe, checkers, othello, and chess. These kinds of games are called games of perfect information because it is possible to see all possible moves. A game like scrabble is not a game of perfect information because it's not possible to see all of your opponents possible moves.

You can think of the algorithm as similar to the human thought process of saying, "OK, if I make this move, then my opponent can only make two moves, and each of those would let me win. So this is the right move to make."

The rest of the article explains how to represent possible moves and evaluate them. An example command-line tic-tac-toe game using Ruby is given.

h2. Representing Moves with the Game Tree Data Structure

Here's an example of a Game Tree for tic-tac-toe:

Representing the game like this allows the computer to evaluate each of its current possible moves by determining whether it will ultimately result in a win or a loss. We'll get into how the computer determines this in the next section, Ranking. Before that, though, we need to clearly define the central concepts defining a Game Tree:

# The board state. Which pieces are in which positions.
# The current player - the player who will be making the next move.
# The next available moves. For humans, a move involves placing a game token. For the computer, it's a matter of selecting the next game state. As humans, we never say, "I've selected the next game state", but it's useful to think of it that way in order to understand the minimax algorithm.
# The game state - the grouping of the three previous concepts.

So, a Game Tree is a structure for organizing all possible (legal) game states by the moves which allow you to transition from one game state to the next. This structure is ideal for allowing the computer to evaluate which moves to make because, by traversing the game tree, a computer can easily "foresee" the outcome of a move and thus "decide" whether to take it.

Next we'll go into detail about how to determine whether a move is good or bad.

h2. Ranking Game States

The basic approach is to provide a numerical value to a move based on whether it will result in a win, draw, or loss. We'll begin illustrating this concept by showing how it applies to final game states, then show how to apply it to intermediate game states.

h3. Final Game States

Have a look at this Game Tree:

It's X's turn, and X has three possible moves, one of which will lead immediately to victory. It's obvious that an AI should select the winning move. The way we ensure this is to give each move a numerical value based on its board state. Let's use the following rankings:

* Win: 1
* Draw: 0
* Lose: -1

Since the lowest-ranked moves correspond with the worst outcomes and highest-ranked moves correspond with the best outcomes, we should choose the move with the highest value. This is the "max" part of "minimax". Below are some more examples of final game states and their numerical values:

You might be wondering whether or not we should apply different rankings based on the player whose turn it is. For now, let's ignore the question entirely and only view things from X's perspective.

Of course, only the most boring game in the world would start out by presenting you with the options of "win immediately" and "don't win immediately." And an algorithm would be useless if it only worked in such a situation. But guess what! Minimax isn't a useless algorithm. Below I'll describe how to determine the ranks of intermediate Game States.

h3. Intermediate Game States

Have a look at the following game tree:

As you can see, in the root Game State, it's X's turn. There are y possible moves, including a winning move. Since this Game State allows X to win, X should select if possible. This Game State is as good as winning, so its rank should be 1. In general, we can say that the rank of an intermediate Game State where X is the current player should be set to the maximum rank of the available moves.

Now have a look at this game tree:

It's O's turn, and there are y possible moves. One of the moves results in an immediate for O. From X's perspective this Game State is equivalent to a loss, since it allows O to select a move that will cause X to lose. Therefore, its rank should be -1. In general, we can say that the rank of an intermediate Game State where O is the current player should be set to the *minimum* rank of the available moves. That's what the "mini" in "minimax" refers to.

To sum up:

* Final Game States are ranked according to whether they're a win, draw, or loss.
* Intermediate Game States are ranked according to whose turn it is and the available moves.
** If it's X's turn, set the rank to that of the *maximum* move available. If a move will result in a win, X should take it.
** If it's O's turn, set the rank to that of the *minimum* move available. If a move will result in a loss, X should avoid it.

And that's the minimax algorithm! Below are more examples illustrating how minimax works, and why it works the way it does.

h2. More Examples

h3. X's Turn, All Moves Result in a Loss for X

Since all moves available to X will result in X losing, this Game State is as good as a loss, and its value should be -1.

h3. O's Turn, All Moves are Wins Result in a Win for X

Since all moves available to O will result in X winning, this Game State is as good as a win for X, and its value should be 1.

h2. Ruby Example

source. minimax/tictactoe.rb

h2. The End

I hope that explains the algorithm! If anything's unclear, please let me know in the comments below. I'd like for this post to explain the algorithm completely, and I'll use any feedback to revise it. Thanks!
